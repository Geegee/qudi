# -*- coding: utf-8 -*-

"""
A module for controlling a camera.

Qudi is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Qudi is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Qudi. If not, see <http://www.gnu.org/licenses/>.

Copyright (c) the Qudi Developers. See the COPYRIGHT.txt file at the
top-level directory of this distribution and at <https://github.com/Ulm-IQO/qudi/>
"""

import numpy as np

from core.module import Connector, ConfigOption, StatusVar
from core.util.mutex import Mutex
from logic.generic_logic import GenericLogic
from qtpy import QtCore


class CameraLogic(GenericLogic):
    """
    Control a camera.
    """
    _modclass = 'cameralogic'
    _modtype = 'logic'

    # declare connectors
    hardware = Connector(interface='CameraInterface')
    savelogic = Connector(interface='SaveLogic')

    _max_fps = ConfigOption('default_exposure', 20)
    _fps = _max_fps

    # signals
    sigUpdateDisplay = QtCore.Signal()
    timer = None

    enabled = False

    _exposure = 1.
    _last_image = None
    _last_image_raw = None

    _subtracted_image = None
    _divided_image = None

    def __init__(self, config, **kwargs):
        super().__init__(config=config, **kwargs)

        self.threadlock = Mutex()

    def on_activate(self):
        """ Initialisation performed during activation of the module.
        """
        self._hardware = self.hardware()
        self._save_logic = self.savelogic()


        self.enabled = False

        self.get_exposure()

        self.timer = QtCore.QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.loop)

    def on_deactivate(self):
        """ Perform required deactivation. """
        pass

    def set_exposure(self, time):
        """ Set exposure of hardware """
        self._hardware.set_exposure(time)
        self.get_exposure()

    def get_exposure(self):
        """ Get exposure of hardware """
        self._exposure = self._hardware.get_exposure()
        self._fps = min(1 / self._exposure, self._max_fps)
        return self._exposure

    def startLoop(self):
        """ Start the data recording loop.
        """
        self.enabled = True
        self.timer.start(1000*1/self._fps)
        if self._hardware.support_live_acquisition():
            self._hardware.start_live_acquisition()
        else:
            self._hardware.start_single_acquisition()

    def stopLoop(self):
        """ Stop the data recording loop.
        """
        self.timer.stop()
        self.enabled = False
        self._hardware.stop_acquisition()

    def save(self):
        """ Save last image to data directory
        """
        data = {'image': self._last_image}
        self._save_logic.save_data(data)


    def treat_raw_image(self):
        """ Take last raw image and update last image with eventual treatment

        This way of doing is dirty, but it's helpful for now.
        Let's hide this feature from GUI so we're not tempted to use it as is
        """
        self._last_image = self._last_image_raw
        try:
            if self._subtracted_image is not None:
                self._last_image = self._last_image - self._subtracted_image
#            if self._divided_image is not None:
#                self._last_image = self._last_image / self._subtracted_image
        except ValueError:
            self.log.warning('Image dimension for treatment do not match.')
            self._subtracted_image = None
            self._divided_image = None


    def loop(self):
        """ Execute step in the data recording loop: save one of each control and process values
        """
        self._last_image_raw = self._hardware.get_acquired_data()
        self.treat_raw_image()
        self.sigUpdateDisplay.emit()
        if self.enabled:
            self.timer.start(1000 * 1 / self._fps)
            if not self._hardware.support_live_acquisition():
                self._hardware.start_single_acquisition()  # the hardware has to check it's not busy

    def get_last_image(self):
        """ Return last acquired image """
        return self._last_image



